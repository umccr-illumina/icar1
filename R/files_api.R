#' Workflow Execution Service
#'
#' No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
#'
#' The version of the OpenAPI document: v1
#' Generated by: https://openapi-generator.tech
#'
#' @docType class
#' @title Files operations
#' @description FilesApi
#' @format An \code{R6Class} generator object
#' @field api_client Handles the client-server communication.
#'
#' @section Methods:
#' \describe{
#' \strong{ ArchiveFile } \emph{ Archive a file }
#' Archives a file to a lower storage cost tier.
#'
#' \itemize{
#' \item \emph{ @param } file_id character
#' \item \emph{ @param } body \link{FileArchiveRequest}
#' \item \emph{ @returnType } \link{FileResponse} \cr
#'
#' \item On encountering errors, an error of subclass ApiException will be thrown.
#'
#' \item status code : 200 | Success.
#'
#' \item return type : FileResponse
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 401 | Unauthorized.
#'
#' \item return type : ErrorResponse
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | File not found.
#'
#' \item return type : ErrorResponse
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 403 | Forbidden.
#'
#' \item return type : ErrorResponse
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 409 | Conflict.
#'
#' \item return type : ErrorResponse
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | Unexpected issue. Please try your request again. If problem persists, please contact the system administrator.
#'
#' \item return type : ErrorResponse
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ BulkFileUpdate } \emph{ Updates list of files with metadata }
#' Updates list of files with metadata
#'
#' \itemize{
#' \item \emph{ @param } body \link{BulkFileUpdateRequest}
#' \item \emph{ @returnType } \link{BulkFileUpdateResponse} \cr
#'
#' \item On encountering errors, an error of subclass ApiException will be thrown.
#'
#' \item status code : 200 | Success.
#'
#' \item return type : BulkFileUpdateResponse
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 202 | Accepted
#'
#' \item return type : BulkFileUpdateResponse
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Bad request.
#'
#' \item return type : ErrorResponse
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 401 | Unauthorized.
#'
#' \item return type : ErrorResponse
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 403 | Forbidden.
#'
#' \item return type : ErrorResponse
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | Unexpected issue. Please try your request again. If problem persists, please contact the system administrator.
#'
#' \item return type : ErrorResponse
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ CompleteFileUpload } \emph{ Complete a file Upload }
#' Complete a file upload operation. If the file was uploaded using multipart uploads, combine all the multiple parts uploaded into one complete file.
#'
#' \itemize{
#' \item \emph{ @param } file_id character
#' \item \emph{ @param } body \link{FileUploadCompleteRequest}
#' \item \emph{ @returnType } \link{FileResponse} \cr
#'
#' \item On encountering errors, an error of subclass ApiException will be thrown.
#'
#' \item status code : 200 | Success.
#'
#' \item return type : FileResponse
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 401 | Unauthorized.
#'
#' \item return type : ErrorResponse
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | File not found.
#'
#' \item return type : ErrorResponse
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 403 | Forbidden.
#'
#' \item return type : ErrorResponse
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 409 | Conflict.
#'
#' \item return type : ErrorResponse
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | Unexpected issue. Please try your request again. If problem persists, please contact the system administrator.
#'
#' \item return type : ErrorResponse
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ CopyFiles } \emph{ Copy list of files }
#' Copies a list of files enumerated by file Ids to a destination folder
#'
#' \itemize{
#' \item \emph{ @param } body \link{FileListCopyRequest}
#' \item \emph{ @returnType } \link{JobResponse} \cr
#'
#' \item On encountering errors, an error of subclass ApiException will be thrown.
#'
#' \item status code : 200 | Success.
#'
#' \item return type : JobResponse
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Bad request.
#'
#' \item return type : ErrorResponse
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 401 | Unauthorized.
#'
#' \item return type : ErrorResponse
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 403 | Forbidden.
#'
#' \item return type : ErrorResponse
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 409 | Conflict
#'
#' \item return type : ErrorResponse
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | Unexpected issue. Please try your request again. If problem persists, please contact the system administrator.
#'
#' \item return type : ErrorResponse
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ CreateFile } \emph{ Create a file entry in GDS and get temporary credentials for upload }
#' Create a file entry in GDS. Returns temporary credentials and presigned url(s) for file upload directly to S3 when the include=objectStoreAccess parameter is used. Volume ID or volume name is required for file creation. If a folder path is provided and does not exist, GDS creates the folder path in the appropriate account automatically.
#'
#' \itemize{
#' \item \emph{ @param } body \link{CreateFileRequest}
#' \item \emph{ @param } include character
#' \item \emph{ @param } upload_part_count integer
#' \item \emph{ @returnType } \link{FileWriteableResponse} \cr
#'
#' \item On encountering errors, an error of subclass ApiException will be thrown.
#'
#' \item status code : 201 | Created new File.
#'
#' \item return type : FileWriteableResponse
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Bad request.
#'
#' \item return type : ErrorResponse
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 401 | Unauthorized.
#'
#' \item return type : ErrorResponse
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 403 | Forbidden.
#'
#' \item return type : ErrorResponse
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 409 | A conflict was found. Make sure the new File doesn't already exist.
#'
#' \item return type : ErrorResponse
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | Unexpected issue. Please try your request again. If problem persists, please contact the system administrator.
#'
#' \item return type : ErrorResponse
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ DeleteFile } \emph{ Permanently delete a file }
#' Permanently delete a file entry and its underlying content
#'
#' \itemize{
#' \item \emph{ @param } file_id character
#'
#' \item On encountering errors, an error of subclass ApiException will be thrown.
#'
#' \item status code : 204 | No Content.
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Bad request.
#'
#' \item return type : ErrorResponse
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 401 | Unauthorized.
#'
#' \item return type : ErrorResponse
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 403 | Forbidden.
#'
#' \item return type : ErrorResponse
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | File not found.
#'
#' \item return type : ErrorResponse
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | Unexpected issue. Please try your request again. If problem persists, please contact the system administrator.
#'
#' \item return type : ErrorResponse
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ GetFile } \emph{ Get details about a file, including a pre-signed URL for download }
#' Get information and details for the specified file ID, including metadata and a pre-signed URL for file download. The URL can be used as a curl command or directly with S3.
#'
#' \itemize{
#' \item \emph{ @param } file_id character
#' \item \emph{ @param } tenant_id character
#' \item \emph{ @param } presigned_url_mode character
#' \item \emph{ @param } include_volume_metadata character
#' \item \emph{ @param } metadata_include character
#' \item \emph{ @param } metadata_exclude character
#' \item \emph{ @param } include character
#' \item \emph{ @returnType } \link{FileResponse} \cr
#'
#' \item On encountering errors, an error of subclass ApiException will be thrown.
#'
#' \item status code : 200 | Success.
#'
#' \item return type : FileResponse
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Bad request.
#'
#' \item return type : ErrorResponse
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 401 | Unauthorized.
#'
#' \item return type : ErrorResponse
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 403 | Forbidden.
#'
#' \item return type : ErrorResponse
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | File not found.
#'
#' \item return type : ErrorResponse
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | Unexpected issue. Please try your request again. If problem persists, please contact the system administrator.
#'
#' \item return type : ErrorResponse
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ ListFiles } \emph{ Get a list of files }
#' Given a volumeId or volume name, get a list of files accessible by the JWT. The default sort returned is alphabetical, ascending. The default page size is 10 items
#'
#' \itemize{
#' \item \emph{ @param } volume_id list( character )
#' \item \emph{ @param } volume_name list( character )
#' \item \emph{ @param } path list( character )
#' \item \emph{ @param } is_uploaded character
#' \item \emph{ @param } archive_status character
#' \item \emph{ @param } recursive character
#' \item \emph{ @param } presigned_url_mode character
#' \item \emph{ @param } include character
#' \item \emph{ @param } page_size integer
#' \item \emph{ @param } page_token character
#' \item \emph{ @param } tenant_id character
#' \item \emph{ @param } metadata_include character
#' \item \emph{ @param } metadata_exclude character
#' \item \emph{ @returnType } \link{FileListResponse} \cr
#'
#' \item On encountering errors, an error of subclass ApiException will be thrown.
#'
#' \item status code : 200 | Success.
#'
#' \item return type : FileListResponse
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Bad request.
#'
#' \item return type : ErrorResponse
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 401 | Unauthorized.
#'
#' \item return type : ErrorResponse
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 403 | Forbidden.
#'
#' \item return type : ErrorResponse
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | Unexpected issue. Please try your request again. If problem persists, please contact the system administrator.
#'
#' \item return type : ErrorResponse
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ ListVolumeFiles } \emph{ Get a list of volume files }
#' Gets file list by volume ID and an array of file IDs. The default sort returned is alphabetical, ascending
#'
#' \itemize{
#' \item \emph{ @param } body \link{VolumeFileListRequest}
#' \item \emph{ @returnType } \link{VolumeFileListResponse} \cr
#'
#' \item On encountering errors, an error of subclass ApiException will be thrown.
#'
#' \item status code : 200 | Success.
#'
#' \item return type : VolumeFileListResponse
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Bad request.
#'
#' \item return type : ErrorResponse
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 401 | Unauthorized.
#'
#' \item return type : ErrorResponse
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 403 | Forbidden.
#'
#' \item return type : ErrorResponse
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | Unexpected issue. Please try your request again. If problem persists, please contact the system administrator.
#'
#' \item return type : ErrorResponse
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ UnarchiveFile } \emph{ Unarchive a file }
#' Unarchive a file from a lower storage cost tier.
#'
#' \itemize{
#' \item \emph{ @param } file_id character
#' \item \emph{ @param } body \link{FileUnarchiveRequest}
#' \item \emph{ @returnType } \link{FileResponse} \cr
#'
#' \item On encountering errors, an error of subclass ApiException will be thrown.
#'
#' \item status code : 202 | Accepted.
#'
#' \item return type : FileResponse
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Bad request.
#'
#' \item return type : ErrorResponse
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 401 | Unauthorized.
#'
#' \item return type : ErrorResponse
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 403 | Forbidden.
#'
#' \item return type : ErrorResponse
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | File not found.
#'
#' \item return type : ErrorResponse
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 409 | Conflict.
#'
#' \item return type : ErrorResponse
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | Unexpected issue. Please try your request again. If problem persists, please contact the system administrator.
#'
#' \item return type : ErrorResponse
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ UpdateFile } \emph{ Update a file entry in GDS and get temporary credentials for upload }
#' Update a file entry in GDS. Returns temporary credentials and presigned url(s) for file upload directly to S3 when the include=objectStoreAccess parameter is used. Note that the currently supported changes to the file resource are updating the file type and the underlying content.
#'
#' \itemize{
#' \item \emph{ @param } file_id character
#' \item \emph{ @param } include character
#' \item \emph{ @param } upload_part_count integer
#' \item \emph{ @param } body \link{UpdateFileRequest}
#' \item \emph{ @returnType } \link{FileWriteableResponse} \cr
#'
#' \item On encountering errors, an error of subclass ApiException will be thrown.
#'
#' \item status code : 200 | Success.
#'
#' \item return type : FileWriteableResponse
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Bad request.
#'
#' \item return type : ErrorResponse
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 401 | Unauthorized.
#'
#' \item return type : ErrorResponse
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 403 | Forbidden.
#'
#' \item return type : ErrorResponse
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | File not found.
#'
#' \item return type : ErrorResponse
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | Unexpected issue. Please try your request again. If problem persists, please contact the system administrator.
#'
#' \item return type : ErrorResponse
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' }
#'
#'
#' @examples
#' \dontrun{
#' ####################  ArchiveFile  ####################
#'
#' library(icar1)
#' var_file_id <- "file_id_example" # character | Unique identifier for the file to be archived.
#' var_body <- FileArchiveRequest$new(FileArchiveStorageTier$new()) # FileArchiveRequest | 
#'
#' #Archive a file
#' api_instance <- FilesApi$new()
#'
#' # Configure API key authorization: Bearer
#' api_instance$api_client$api_keys["Authorization"] <- Sys.getenv("API_KEY")
#'
#'
#'
#' ####################  BulkFileUpdate  ####################
#'
#' library(icar1)
#' var_body <- BulkFileUpdateRequest$new(c(BulkFileUpdateItem$new("id_example", 123, "format_example", "formatEdam_example", FileLifeCycleSettings$new("timeGracePeriodEnds_example", "timeToBeArchived_example", "timeToBeDeleted_example", FileArchiveStorageTier$new()))), 123) # BulkFileUpdateRequest |  (Optional)
#'
#' #Updates list of files with metadata
#' api_instance <- FilesApi$new()
#'
#' # Configure API key authorization: Bearer
#' api_instance$api_client$api_keys["Authorization"] <- Sys.getenv("API_KEY")
#'
#'
#'
#' ####################  CompleteFileUpload  ####################
#'
#' library(icar1)
#' var_file_id <- "file_id_example" # character | Unique identifier for the file upload to be completed.
#' var_body <- FileUploadCompleteRequest$new("multipartUploadId_example", c(PartEtag$new(123, "etag_example"))) # FileUploadCompleteRequest | 
#'
#' #Complete a file Upload
#' api_instance <- FilesApi$new()
#'
#' # Configure API key authorization: Bearer
#' api_instance$api_client$api_keys["Authorization"] <- Sys.getenv("API_KEY")
#'
#'
#'
#' ####################  CopyFiles  ####################
#'
#' library(icar1)
#' var_body <- FileListCopyRequest$new("sourceVolumeId_example", "destinationFolderId_example", c("ids_example"), c("metadataToCopy_example"), "duplicateFileAction_example") # FileListCopyRequest | 
#'
#' #Copy list of files
#' api_instance <- FilesApi$new()
#'
#' # Configure API key authorization: Bearer
#' api_instance$api_client$api_keys["Authorization"] <- Sys.getenv("API_KEY")
#'
#'
#'
#' ####################  CreateFile  ####################
#'
#' library(icar1)
#' var_body <- CreateFileRequest$new("name_example", "volumeId_example", "folderPath_example", "type_example", "volumeName_example", "format_example", "formatEdam_example", 123) # CreateFileRequest | 
#' var_include <- "include_example" # character | Optionally include additional fields in the response.              Possible values: ObjectStoreAccess (Optional)
#' var_upload_part_count <- 56 # integer | Optional number of parts for the presigned url for uploads (1 - 10000) (Optional)
#'
#' #Create a file entry in GDS and get temporary credentials for upload
#' api_instance <- FilesApi$new()
#'
#' # Configure API key authorization: Bearer
#' api_instance$api_client$api_keys["Authorization"] <- Sys.getenv("API_KEY")
#'
#'
#'
#' ####################  DeleteFile  ####################
#'
#' library(icar1)
#' var_file_id <- "file_id_example" # character | Unique identifier for the file to delete.
#'
#' #Permanently delete a file
#' api_instance <- FilesApi$new()
#'
#' # Configure API key authorization: Bearer
#' api_instance$api_client$api_keys["Authorization"] <- Sys.getenv("API_KEY")
#'
#'
#'
#' ####################  GetFile  ####################
#'
#' library(icar1)
#' var_file_id <- "file_id_example" # character | Unique identifier for the file to retrieve.
#' var_tenant_id <- "tenant_id_example" # character | Optional parameter to see shared data in another tenant (Optional)
#' var_presigned_url_mode <- "presigned_url_mode_example" # character | Optional parameter to specify presigned url's content-disposition. If not specified, the browser will determine the default behavior.              Possible values: Attachment, Inline, Browser (Optional)
#' var_include_volume_metadata <- "include_volume_metadata_example" # character | Optional parameter to return volume's metadata (Optional)
#' var_metadata_include <- "metadata_include_example" # character | Optional parameter to specify comma separated patterns to include metadata by their field names. (Optional)
#' var_metadata_exclude <- "metadata_exclude_example" # character | Optional parameter to specify comma separated patterns to exclude metadata by their field names. (Optional)
#' var_include <- "include_example" # character | Optionally include additional fields in the response.              Possible values: ObjectStoreAccess (Optional)
#'
#' #Get details about a file, including a pre-signed URL for download
#' api_instance <- FilesApi$new()
#'
#' # Configure API key authorization: Bearer
#' api_instance$api_client$api_keys["Authorization"] <- Sys.getenv("API_KEY")
#'
#'
#'
#' ####################  ListFiles  ####################
#'
#' library(icar1)
#' var_volume_id <- c("inner_example") # array[character] | Optional field that specifies comma-separated volume IDs to include in the list (Optional)
#' var_volume_name <- c("inner_example") # array[character] | Optional field that specifies comma-separated volume names to include in the list (Optional)
#' var_path <- c("inner_example") # array[character] | Optional field that specifies comma-separated paths to include in the list. Value can use wildcards (e.g. /a/b/c/*) or exact matches (e.g. /a/b/c/d/). (Optional)
#' var_is_uploaded <- "is_uploaded_example" # character | Optional field to filter by Uploaded files (Optional)
#' var_archive_status <- "archive_status_example" # character | Optional field that specifies comma-separated Archive Statuses to include in the list (Optional)
#' var_recursive <- "recursive_example" # character | Optional field to specify if files should be returned recursively in and under the specified paths, or only directly in the specified paths (Optional)
#' var_presigned_url_mode <- "presigned_url_mode_example" # character | Optional parameter to specify presigned url's content-disposition. If not specified, the browser will determine the default behavior.  Possible values: Attachment, Inline, Browser (Optional)
#' var_include <- "include_example" # character | Optionally include additional fields in the response. Multiple fields can be included by comma-separation.  Possible values: TotalItemCount, PresignedUrl, InheritedAcl (Optional)
#' var_page_size <- 56 # integer | START_DESC END_DESC (Optional)
#' var_page_token <- "page_token_example" # character | START_DESC END_DESC (Optional)
#' var_tenant_id <- "tenant_id_example" # character | Optional parameter to see shared data in another tenant (Optional)
#' var_metadata_include <- "metadata_include_example" # character | Optional parameter to specify comma separated patterns to include metadata by their field names. (Optional)
#' var_metadata_exclude <- "metadata_exclude_example" # character | Optional parameter to specify comma separated patterns to exclude metadata by their field names. (Optional)
#'
#' #Get a list of files
#' api_instance <- FilesApi$new()
#'
#' # Configure API key authorization: Bearer
#' api_instance$api_client$api_keys["Authorization"] <- Sys.getenv("API_KEY")
#'
#'
#'
#' ####################  ListVolumeFiles  ####################
#'
#' library(icar1)
#' var_body <- VolumeFileListRequest$new("volumeId_example", c("fileIds_example"), "includePresignedUrl_example", "presignedUrlMode_example") # VolumeFileListRequest | 
#'
#' #Get a list of volume files
#' api_instance <- FilesApi$new()
#'
#' # Configure API key authorization: Bearer
#' api_instance$api_client$api_keys["Authorization"] <- Sys.getenv("API_KEY")
#'
#'
#'
#' ####################  UnarchiveFile  ####################
#'
#' library(icar1)
#' var_file_id <- "file_id_example" # character | Unique identifier for the file to be unarchived.
#' var_body <- FileUnarchiveRequest$new("restoreSpeed_example") # FileUnarchiveRequest | 
#'
#' #Unarchive a file
#' api_instance <- FilesApi$new()
#'
#' # Configure API key authorization: Bearer
#' api_instance$api_client$api_keys["Authorization"] <- Sys.getenv("API_KEY")
#'
#'
#'
#' ####################  UpdateFile  ####################
#'
#' library(icar1)
#' var_file_id <- "file_id_example" # character | Unique identifier for the file to be updated.
#' var_include <- "include_example" # character | Optionally include additional fields in the response.              Possible values: ObjectStoreAccess (Optional)
#' var_upload_part_count <- 56 # integer | Optional number of parts for the presigned url for uploads (1 - 10000) (Optional)
#' var_body <- UpdateFileRequest$new("type_example", "format_example", "formatEdam_example", FileLifeCycleSettings$new("timeGracePeriodEnds_example", "timeToBeArchived_example", "timeToBeDeleted_example", FileArchiveStorageTier$new()), 123) # UpdateFileRequest |  (Optional)
#'
#' #Update a file entry in GDS and get temporary credentials for upload
#' api_instance <- FilesApi$new()
#'
#' # Configure API key authorization: Bearer
#' api_instance$api_client$api_keys["Authorization"] <- Sys.getenv("API_KEY")
#'
#'
#'
#' }
#' @importFrom R6 R6Class
#' @importFrom base64enc base64encode
#' @importFrom rlang abort
#' @export
FilesApi <- R6::R6Class(
  "FilesApi",
  public = list(
    api_client = NULL,
    #' Initialize a new FilesApi.
    #'
    #' @description
    #' Initialize a new FilesApi.
    #'
    #' @param api_client An instance of API client.
    #' @export
    initialize = function(api_client) {
      if (!missing(api_client)) {
        self$api_client <- api_client
      } else {
        self$api_client <- ApiClient$new()
      }
    },
    #' Archive a file
    #'
    #' @description
    #' Archive a file
    #'
    #' @param file_id Unique identifier for the file to be archived.
    #' @param body 
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return FileResponse
    #' @export
    ArchiveFile = function(file_id, body, data_file = NULL, ...) {
      local_var_response <- self$ArchiveFileWithHttpInfo(file_id, body, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        local_var_response$content
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        local_var_response
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        local_var_response
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        local_var_response
      }
    },
    #' Archive a file
    #'
    #' @description
    #' Archive a file
    #'
    #' @param file_id Unique identifier for the file to be archived.
    #' @param body 
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return API response (FileResponse) with additional information such as HTTP status code, headers
    #' @export
    ArchiveFileWithHttpInfo = function(file_id, body, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`file_id`)) {
        rlang::abort(message = "Missing required parameter `file_id`.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Missing required parameter `file_id`."))
      }

      if (missing(`body`)) {
        rlang::abort(message = "Missing required parameter `body`.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Missing required parameter `body`."))
      }



      if (!is.null(`body`)) {
        local_var_body <- `body`$toJSONString()
      } else {
        body <- NULL
      }

      local_var_url_path <- "/v1/files/{fileId}:archive"
      if (!missing(`file_id`)) {
        local_var_url_path <- gsub("\\{fileId\\}", URLencode(as.character(`file_id`), reserved = TRUE), local_var_url_path)
      }

      # API key authentication
      if ("Authorization" %in% names(self$api_client$api_keys) && nchar(self$api_client$api_keys["Authorization"]) > 0) {
        header_params["Authorization"] <- paste(unlist(self$api_client$api_keys["Authorization"]), collapse = "")
      }

      # The Accept request HTTP header
      local_var_accepts <- list("application/json")

      # The Content-Type representation header
      local_var_content_types <- list("application/json-patch+json", "application/json", "text/json", "application/*+json")

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "POST",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          write(local_var_resp$response, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$deserialize(local_var_resp$response, "FileResponse", loadNamespace("icar1")),
          error = function(e) {
            rlang::abort(message = "Failed to deserialize response",
                         .subclass = "ApiException",
                         ApiException = ApiException$new(http_response = local_var_resp))
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        local_var_resp
      } else if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        local_var_resp
      }
    },
    #' Updates list of files with metadata
    #'
    #' @description
    #' Updates list of files with metadata
    #'
    #' @param body (optional) No description
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return BulkFileUpdateResponse
    #' @export
    BulkFileUpdate = function(body = NULL, data_file = NULL, ...) {
      local_var_response <- self$BulkFileUpdateWithHttpInfo(body, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        local_var_response$content
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        local_var_response
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        local_var_response
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        local_var_response
      }
    },
    #' Updates list of files with metadata
    #'
    #' @description
    #' Updates list of files with metadata
    #'
    #' @param body (optional) No description
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return API response (BulkFileUpdateResponse) with additional information such as HTTP status code, headers
    #' @export
    BulkFileUpdateWithHttpInfo = function(body = NULL, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE


      if (!is.null(`body`)) {
        local_var_body <- `body`$toJSONString()
      } else {
        body <- NULL
      }

      local_var_url_path <- "/v1/files"
      # API key authentication
      if ("Authorization" %in% names(self$api_client$api_keys) && nchar(self$api_client$api_keys["Authorization"]) > 0) {
        header_params["Authorization"] <- paste(unlist(self$api_client$api_keys["Authorization"]), collapse = "")
      }

      # The Accept request HTTP header
      local_var_accepts <- list("text/plain", "application/json", "text/json")

      # The Content-Type representation header
      local_var_content_types <- list("application/json")

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "PATCH",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          write(local_var_resp$response, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$deserialize(local_var_resp$response, "BulkFileUpdateResponse", loadNamespace("icar1")),
          error = function(e) {
            rlang::abort(message = "Failed to deserialize response",
                         .subclass = "ApiException",
                         ApiException = ApiException$new(http_response = local_var_resp))
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        local_var_resp
      } else if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        local_var_resp
      }
    },
    #' Complete a file Upload
    #'
    #' @description
    #' Complete a file Upload
    #'
    #' @param file_id Unique identifier for the file upload to be completed.
    #' @param body 
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return FileResponse
    #' @export
    CompleteFileUpload = function(file_id, body, data_file = NULL, ...) {
      local_var_response <- self$CompleteFileUploadWithHttpInfo(file_id, body, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        local_var_response$content
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        local_var_response
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        local_var_response
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        local_var_response
      }
    },
    #' Complete a file Upload
    #'
    #' @description
    #' Complete a file Upload
    #'
    #' @param file_id Unique identifier for the file upload to be completed.
    #' @param body 
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return API response (FileResponse) with additional information such as HTTP status code, headers
    #' @export
    CompleteFileUploadWithHttpInfo = function(file_id, body, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`file_id`)) {
        rlang::abort(message = "Missing required parameter `file_id`.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Missing required parameter `file_id`."))
      }

      if (missing(`body`)) {
        rlang::abort(message = "Missing required parameter `body`.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Missing required parameter `body`."))
      }



      if (!is.null(`body`)) {
        local_var_body <- `body`$toJSONString()
      } else {
        body <- NULL
      }

      local_var_url_path <- "/v1/files/{fileId}:completeUpload"
      if (!missing(`file_id`)) {
        local_var_url_path <- gsub("\\{fileId\\}", URLencode(as.character(`file_id`), reserved = TRUE), local_var_url_path)
      }

      # API key authentication
      if ("Authorization" %in% names(self$api_client$api_keys) && nchar(self$api_client$api_keys["Authorization"]) > 0) {
        header_params["Authorization"] <- paste(unlist(self$api_client$api_keys["Authorization"]), collapse = "")
      }

      # The Accept request HTTP header
      local_var_accepts <- list("application/json")

      # The Content-Type representation header
      local_var_content_types <- list("application/json-patch+json", "application/json", "text/json", "application/*+json")

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "POST",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          write(local_var_resp$response, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$deserialize(local_var_resp$response, "FileResponse", loadNamespace("icar1")),
          error = function(e) {
            rlang::abort(message = "Failed to deserialize response",
                         .subclass = "ApiException",
                         ApiException = ApiException$new(http_response = local_var_resp))
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        local_var_resp
      } else if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        local_var_resp
      }
    },
    #' Copy list of files
    #'
    #' @description
    #' Copy list of files
    #'
    #' @param body 
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return JobResponse
    #' @export
    CopyFiles = function(body, data_file = NULL, ...) {
      local_var_response <- self$CopyFilesWithHttpInfo(body, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        local_var_response$content
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        local_var_response
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        local_var_response
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        local_var_response
      }
    },
    #' Copy list of files
    #'
    #' @description
    #' Copy list of files
    #'
    #' @param body 
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return API response (JobResponse) with additional information such as HTTP status code, headers
    #' @export
    CopyFilesWithHttpInfo = function(body, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`body`)) {
        rlang::abort(message = "Missing required parameter `body`.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Missing required parameter `body`."))
      }


      if (!is.null(`body`)) {
        local_var_body <- `body`$toJSONString()
      } else {
        body <- NULL
      }

      local_var_url_path <- "/v1/files/copy"
      # API key authentication
      if ("Authorization" %in% names(self$api_client$api_keys) && nchar(self$api_client$api_keys["Authorization"]) > 0) {
        header_params["Authorization"] <- paste(unlist(self$api_client$api_keys["Authorization"]), collapse = "")
      }

      # The Accept request HTTP header
      local_var_accepts <- list("application/json")

      # The Content-Type representation header
      local_var_content_types <- list("application/json-patch+json", "application/json", "text/json", "application/*+json")

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "POST",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          write(local_var_resp$response, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$deserialize(local_var_resp$response, "JobResponse", loadNamespace("icar1")),
          error = function(e) {
            rlang::abort(message = "Failed to deserialize response",
                         .subclass = "ApiException",
                         ApiException = ApiException$new(http_response = local_var_resp))
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        local_var_resp
      } else if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        local_var_resp
      }
    },
    #' Create a file entry in GDS and get temporary credentials for upload
    #'
    #' @description
    #' Create a file entry in GDS and get temporary credentials for upload
    #'
    #' @param body 
    #' @param include (optional) Optionally include additional fields in the response.              Possible values: ObjectStoreAccess
    #' @param upload_part_count (optional) Optional number of parts for the presigned url for uploads (1 - 10000)
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return FileWriteableResponse
    #' @export
    CreateFile = function(body, include = NULL, upload_part_count = NULL, data_file = NULL, ...) {
      local_var_response <- self$CreateFileWithHttpInfo(body, include, upload_part_count, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        local_var_response$content
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        local_var_response
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        local_var_response
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        local_var_response
      }
    },
    #' Create a file entry in GDS and get temporary credentials for upload
    #'
    #' @description
    #' Create a file entry in GDS and get temporary credentials for upload
    #'
    #' @param body 
    #' @param include (optional) Optionally include additional fields in the response.              Possible values: ObjectStoreAccess
    #' @param upload_part_count (optional) Optional number of parts for the presigned url for uploads (1 - 10000)
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return API response (FileWriteableResponse) with additional information such as HTTP status code, headers
    #' @export
    CreateFileWithHttpInfo = function(body, include = NULL, upload_part_count = NULL, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`body`)) {
        rlang::abort(message = "Missing required parameter `body`.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Missing required parameter `body`."))
      }



      if (`upload_part_count` > 10000) {
        rlang::abort(message = "Invalid value for `upload_part_count` when calling FilesApi$CreateFile, must be smaller than or equal to 10000.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `upload_part_count` when calling FilesApi$CreateFile, must be smaller than or equal to 10000."))
      }
      if (`upload_part_count` < 1) {
        rlang::abort(message = "Invalid value for `upload_part_count` when calling FilesApi$CreateFile, must be bigger than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `upload_part_count` when calling FilesApi$CreateFile, must be bigger than or equal to 1."))
      }

      query_params[["include"]] <- `include`

      query_params[["uploadPartCount"]] <- `upload_part_count`

      if (!is.null(`body`)) {
        local_var_body <- `body`$toJSONString()
      } else {
        body <- NULL
      }

      local_var_url_path <- "/v1/files"
      # API key authentication
      if ("Authorization" %in% names(self$api_client$api_keys) && nchar(self$api_client$api_keys["Authorization"]) > 0) {
        header_params["Authorization"] <- paste(unlist(self$api_client$api_keys["Authorization"]), collapse = "")
      }

      # The Accept request HTTP header
      local_var_accepts <- list("application/json")

      # The Content-Type representation header
      local_var_content_types <- list("application/json")

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "POST",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          write(local_var_resp$response, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$deserialize(local_var_resp$response, "FileWriteableResponse", loadNamespace("icar1")),
          error = function(e) {
            rlang::abort(message = "Failed to deserialize response",
                         .subclass = "ApiException",
                         ApiException = ApiException$new(http_response = local_var_resp))
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        local_var_resp
      } else if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        local_var_resp
      }
    },
    #' Permanently delete a file
    #'
    #' @description
    #' Permanently delete a file
    #'
    #' @param file_id Unique identifier for the file to delete.
    #' @param ... Other optional arguments
    #' @return void
    #' @export
    DeleteFile = function(file_id, ...) {
      local_var_response <- self$DeleteFileWithHttpInfo(file_id, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        local_var_response$content
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        local_var_response
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        local_var_response
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        local_var_response
      }
    },
    #' Permanently delete a file
    #'
    #' @description
    #' Permanently delete a file
    #'
    #' @param file_id Unique identifier for the file to delete.
    #' @param ... Other optional arguments
    #' @return API response (void) with additional information such as HTTP status code, headers
    #' @export
    DeleteFileWithHttpInfo = function(file_id, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`file_id`)) {
        rlang::abort(message = "Missing required parameter `file_id`.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Missing required parameter `file_id`."))
      }


      local_var_url_path <- "/v1/files/{fileId}"
      if (!missing(`file_id`)) {
        local_var_url_path <- gsub("\\{fileId\\}", URLencode(as.character(`file_id`), reserved = TRUE), local_var_url_path)
      }

      # API key authentication
      if ("Authorization" %in% names(self$api_client$api_keys) && nchar(self$api_client$api_keys["Authorization"]) > 0) {
        header_params["Authorization"] <- paste(unlist(self$api_client$api_keys["Authorization"]), collapse = "")
      }

      # The Accept request HTTP header
      local_var_accepts <- list("text/plain", "application/json", "text/json")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "DELETE",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        local_var_resp$content <- NULL
        local_var_resp
      } else if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        local_var_resp
      }
    },
    #' Get details about a file, including a pre-signed URL for download
    #'
    #' @description
    #' Get details about a file, including a pre-signed URL for download
    #'
    #' @param file_id Unique identifier for the file to retrieve.
    #' @param tenant_id (optional) Optional parameter to see shared data in another tenant
    #' @param presigned_url_mode (optional) Optional parameter to specify presigned url's content-disposition. If not specified, the browser will determine the default behavior.              Possible values: Attachment, Inline, Browser
    #' @param include_volume_metadata (optional) Optional parameter to return volume's metadata
    #' @param metadata_include (optional) Optional parameter to specify comma separated patterns to include metadata by their field names.
    #' @param metadata_exclude (optional) Optional parameter to specify comma separated patterns to exclude metadata by their field names.
    #' @param include (optional) Optionally include additional fields in the response.              Possible values: ObjectStoreAccess
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return FileResponse
    #' @export
    GetFile = function(file_id, tenant_id = NULL, presigned_url_mode = NULL, include_volume_metadata = NULL, metadata_include = NULL, metadata_exclude = NULL, include = NULL, data_file = NULL, ...) {
      local_var_response <- self$GetFileWithHttpInfo(file_id, tenant_id, presigned_url_mode, include_volume_metadata, metadata_include, metadata_exclude, include, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        local_var_response$content
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        local_var_response
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        local_var_response
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        local_var_response
      }
    },
    #' Get details about a file, including a pre-signed URL for download
    #'
    #' @description
    #' Get details about a file, including a pre-signed URL for download
    #'
    #' @param file_id Unique identifier for the file to retrieve.
    #' @param tenant_id (optional) Optional parameter to see shared data in another tenant
    #' @param presigned_url_mode (optional) Optional parameter to specify presigned url's content-disposition. If not specified, the browser will determine the default behavior.              Possible values: Attachment, Inline, Browser
    #' @param include_volume_metadata (optional) Optional parameter to return volume's metadata
    #' @param metadata_include (optional) Optional parameter to specify comma separated patterns to include metadata by their field names.
    #' @param metadata_exclude (optional) Optional parameter to specify comma separated patterns to exclude metadata by their field names.
    #' @param include (optional) Optionally include additional fields in the response.              Possible values: ObjectStoreAccess
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return API response (FileResponse) with additional information such as HTTP status code, headers
    #' @export
    GetFileWithHttpInfo = function(file_id, tenant_id = NULL, presigned_url_mode = NULL, include_volume_metadata = NULL, metadata_include = NULL, metadata_exclude = NULL, include = NULL, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`file_id`)) {
        rlang::abort(message = "Missing required parameter `file_id`.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Missing required parameter `file_id`."))
      }








      query_params[["tenantId"]] <- `tenant_id`

      query_params[["presignedUrlMode"]] <- `presigned_url_mode`

      query_params[["includeVolumeMetadata"]] <- `include_volume_metadata`

      query_params[["metadata.include"]] <- `metadata_include`

      query_params[["metadata.exclude"]] <- `metadata_exclude`

      query_params[["include"]] <- `include`

      local_var_url_path <- "/v1/files/{fileId}"
      if (!missing(`file_id`)) {
        local_var_url_path <- gsub("\\{fileId\\}", URLencode(as.character(`file_id`), reserved = TRUE), local_var_url_path)
      }

      # API key authentication
      if ("Authorization" %in% names(self$api_client$api_keys) && nchar(self$api_client$api_keys["Authorization"]) > 0) {
        header_params["Authorization"] <- paste(unlist(self$api_client$api_keys["Authorization"]), collapse = "")
      }

      # The Accept request HTTP header
      local_var_accepts <- list("application/json")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          write(local_var_resp$response, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$deserialize(local_var_resp$response, "FileResponse", loadNamespace("icar1")),
          error = function(e) {
            rlang::abort(message = "Failed to deserialize response",
                         .subclass = "ApiException",
                         ApiException = ApiException$new(http_response = local_var_resp))
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        local_var_resp
      } else if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        local_var_resp
      }
    },
    #' Get a list of files
    #'
    #' @description
    #' Get a list of files
    #'
    #' @param volume_id (optional) Optional field that specifies comma-separated volume IDs to include in the list
    #' @param volume_name (optional) Optional field that specifies comma-separated volume names to include in the list
    #' @param path (optional) Optional field that specifies comma-separated paths to include in the list. Value can use wildcards (e.g. /a/b/c/*) or exact matches (e.g. /a/b/c/d/).
    #' @param is_uploaded (optional) Optional field to filter by Uploaded files
    #' @param archive_status (optional) Optional field that specifies comma-separated Archive Statuses to include in the list
    #' @param recursive (optional) Optional field to specify if files should be returned recursively in and under the specified paths, or only directly in the specified paths
    #' @param presigned_url_mode (optional) Optional parameter to specify presigned url's content-disposition. If not specified, the browser will determine the default behavior.  Possible values: Attachment, Inline, Browser
    #' @param include (optional) Optionally include additional fields in the response. Multiple fields can be included by comma-separation.  Possible values: TotalItemCount, PresignedUrl, InheritedAcl
    #' @param page_size (optional) START_DESC END_DESC
    #' @param page_token (optional) START_DESC END_DESC
    #' @param tenant_id (optional) Optional parameter to see shared data in another tenant
    #' @param metadata_include (optional) Optional parameter to specify comma separated patterns to include metadata by their field names.
    #' @param metadata_exclude (optional) Optional parameter to specify comma separated patterns to exclude metadata by their field names.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return FileListResponse
    #' @export
    ListFiles = function(volume_id = NULL, volume_name = NULL, path = NULL, is_uploaded = NULL, archive_status = NULL, recursive = NULL, presigned_url_mode = NULL, include = NULL, page_size = NULL, page_token = NULL, tenant_id = NULL, metadata_include = NULL, metadata_exclude = NULL, data_file = NULL, ...) {
      local_var_response <- self$ListFilesWithHttpInfo(volume_id, volume_name, path, is_uploaded, archive_status, recursive, presigned_url_mode, include, page_size, page_token, tenant_id, metadata_include, metadata_exclude, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        local_var_response$content
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        local_var_response
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        local_var_response
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        local_var_response
      }
    },
    #' Get a list of files
    #'
    #' @description
    #' Get a list of files
    #'
    #' @param volume_id (optional) Optional field that specifies comma-separated volume IDs to include in the list
    #' @param volume_name (optional) Optional field that specifies comma-separated volume names to include in the list
    #' @param path (optional) Optional field that specifies comma-separated paths to include in the list. Value can use wildcards (e.g. /a/b/c/*) or exact matches (e.g. /a/b/c/d/).
    #' @param is_uploaded (optional) Optional field to filter by Uploaded files
    #' @param archive_status (optional) Optional field that specifies comma-separated Archive Statuses to include in the list
    #' @param recursive (optional) Optional field to specify if files should be returned recursively in and under the specified paths, or only directly in the specified paths
    #' @param presigned_url_mode (optional) Optional parameter to specify presigned url's content-disposition. If not specified, the browser will determine the default behavior.  Possible values: Attachment, Inline, Browser
    #' @param include (optional) Optionally include additional fields in the response. Multiple fields can be included by comma-separation.  Possible values: TotalItemCount, PresignedUrl, InheritedAcl
    #' @param page_size (optional) START_DESC END_DESC
    #' @param page_token (optional) START_DESC END_DESC
    #' @param tenant_id (optional) Optional parameter to see shared data in another tenant
    #' @param metadata_include (optional) Optional parameter to specify comma separated patterns to include metadata by their field names.
    #' @param metadata_exclude (optional) Optional parameter to specify comma separated patterns to exclude metadata by their field names.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return API response (FileListResponse) with additional information such as HTTP status code, headers
    #' @export
    ListFilesWithHttpInfo = function(volume_id = NULL, volume_name = NULL, path = NULL, is_uploaded = NULL, archive_status = NULL, recursive = NULL, presigned_url_mode = NULL, include = NULL, page_size = NULL, page_token = NULL, tenant_id = NULL, metadata_include = NULL, metadata_exclude = NULL, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE









      if (`page_size` > 10000) {
        rlang::abort(message = "Invalid value for `page_size` when calling FilesApi$ListFiles, must be smaller than or equal to 10000.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `page_size` when calling FilesApi$ListFiles, must be smaller than or equal to 10000."))
      }
      if (`page_size` < 0) {
        rlang::abort(message = "Invalid value for `page_size` when calling FilesApi$ListFiles, must be bigger than or equal to 0.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `page_size` when calling FilesApi$ListFiles, must be bigger than or equal to 0."))
      }





      # no explore
      query_params[["volume.id"]] <- I(paste(lapply(`volume_id`, URLencode, reserved = TRUE), collapse = ","))

      # no explore
      query_params[["volume.name"]] <- I(paste(lapply(`volume_name`, URLencode, reserved = TRUE), collapse = ","))

      # no explore
      query_params[["path"]] <- I(paste(lapply(`path`, URLencode, reserved = TRUE), collapse = ","))

      query_params[["isUploaded"]] <- `is_uploaded`

      query_params[["archiveStatus"]] <- `archive_status`

      query_params[["recursive"]] <- `recursive`

      query_params[["presignedUrlMode"]] <- `presigned_url_mode`

      query_params[["include"]] <- `include`

      query_params[["pageSize"]] <- `page_size`

      query_params[["pageToken"]] <- `page_token`

      query_params[["tenantId"]] <- `tenant_id`

      query_params[["metadata.include"]] <- `metadata_include`

      query_params[["metadata.exclude"]] <- `metadata_exclude`

      local_var_url_path <- "/v1/files"
      # API key authentication
      if ("Authorization" %in% names(self$api_client$api_keys) && nchar(self$api_client$api_keys["Authorization"]) > 0) {
        header_params["Authorization"] <- paste(unlist(self$api_client$api_keys["Authorization"]), collapse = "")
      }

      # The Accept request HTTP header
      local_var_accepts <- list("application/json")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          write(local_var_resp$response, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$deserialize(local_var_resp$response, "FileListResponse", loadNamespace("icar1")),
          error = function(e) {
            rlang::abort(message = "Failed to deserialize response",
                         .subclass = "ApiException",
                         ApiException = ApiException$new(http_response = local_var_resp))
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        local_var_resp
      } else if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        local_var_resp
      }
    },
    #' Get a list of volume files
    #'
    #' @description
    #' Get a list of volume files
    #'
    #' @param body 
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return VolumeFileListResponse
    #' @export
    ListVolumeFiles = function(body, data_file = NULL, ...) {
      local_var_response <- self$ListVolumeFilesWithHttpInfo(body, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        local_var_response$content
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        local_var_response
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        local_var_response
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        local_var_response
      }
    },
    #' Get a list of volume files
    #'
    #' @description
    #' Get a list of volume files
    #'
    #' @param body 
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return API response (VolumeFileListResponse) with additional information such as HTTP status code, headers
    #' @export
    ListVolumeFilesWithHttpInfo = function(body, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`body`)) {
        rlang::abort(message = "Missing required parameter `body`.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Missing required parameter `body`."))
      }


      if (!is.null(`body`)) {
        local_var_body <- `body`$toJSONString()
      } else {
        body <- NULL
      }

      local_var_url_path <- "/v1/files/list"
      # API key authentication
      if ("Authorization" %in% names(self$api_client$api_keys) && nchar(self$api_client$api_keys["Authorization"]) > 0) {
        header_params["Authorization"] <- paste(unlist(self$api_client$api_keys["Authorization"]), collapse = "")
      }

      # The Accept request HTTP header
      local_var_accepts <- list("application/json")

      # The Content-Type representation header
      local_var_content_types <- list("application/json-patch+json", "application/json", "text/json", "application/*+json")

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "POST",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          write(local_var_resp$response, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$deserialize(local_var_resp$response, "VolumeFileListResponse", loadNamespace("icar1")),
          error = function(e) {
            rlang::abort(message = "Failed to deserialize response",
                         .subclass = "ApiException",
                         ApiException = ApiException$new(http_response = local_var_resp))
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        local_var_resp
      } else if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        local_var_resp
      }
    },
    #' Unarchive a file
    #'
    #' @description
    #' Unarchive a file
    #'
    #' @param file_id Unique identifier for the file to be unarchived.
    #' @param body 
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return FileResponse
    #' @export
    UnarchiveFile = function(file_id, body, data_file = NULL, ...) {
      local_var_response <- self$UnarchiveFileWithHttpInfo(file_id, body, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        local_var_response$content
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        local_var_response
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        local_var_response
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        local_var_response
      }
    },
    #' Unarchive a file
    #'
    #' @description
    #' Unarchive a file
    #'
    #' @param file_id Unique identifier for the file to be unarchived.
    #' @param body 
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return API response (FileResponse) with additional information such as HTTP status code, headers
    #' @export
    UnarchiveFileWithHttpInfo = function(file_id, body, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`file_id`)) {
        rlang::abort(message = "Missing required parameter `file_id`.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Missing required parameter `file_id`."))
      }

      if (missing(`body`)) {
        rlang::abort(message = "Missing required parameter `body`.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Missing required parameter `body`."))
      }



      if (!is.null(`body`)) {
        local_var_body <- `body`$toJSONString()
      } else {
        body <- NULL
      }

      local_var_url_path <- "/v1/files/{fileId}:unarchive"
      if (!missing(`file_id`)) {
        local_var_url_path <- gsub("\\{fileId\\}", URLencode(as.character(`file_id`), reserved = TRUE), local_var_url_path)
      }

      # API key authentication
      if ("Authorization" %in% names(self$api_client$api_keys) && nchar(self$api_client$api_keys["Authorization"]) > 0) {
        header_params["Authorization"] <- paste(unlist(self$api_client$api_keys["Authorization"]), collapse = "")
      }

      # The Accept request HTTP header
      local_var_accepts <- list("application/json")

      # The Content-Type representation header
      local_var_content_types <- list("application/json-patch+json", "application/json", "text/json", "application/*+json")

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "POST",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          write(local_var_resp$response, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$deserialize(local_var_resp$response, "FileResponse", loadNamespace("icar1")),
          error = function(e) {
            rlang::abort(message = "Failed to deserialize response",
                         .subclass = "ApiException",
                         ApiException = ApiException$new(http_response = local_var_resp))
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        local_var_resp
      } else if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        local_var_resp
      }
    },
    #' Update a file entry in GDS and get temporary credentials for upload
    #'
    #' @description
    #' Update a file entry in GDS and get temporary credentials for upload
    #'
    #' @param file_id Unique identifier for the file to be updated.
    #' @param include (optional) Optionally include additional fields in the response.              Possible values: ObjectStoreAccess
    #' @param upload_part_count (optional) Optional number of parts for the presigned url for uploads (1 - 10000)
    #' @param body (optional) No description
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return FileWriteableResponse
    #' @export
    UpdateFile = function(file_id, include = NULL, upload_part_count = NULL, body = NULL, data_file = NULL, ...) {
      local_var_response <- self$UpdateFileWithHttpInfo(file_id, include, upload_part_count, body, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        local_var_response$content
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        local_var_response
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        local_var_response
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        local_var_response
      }
    },
    #' Update a file entry in GDS and get temporary credentials for upload
    #'
    #' @description
    #' Update a file entry in GDS and get temporary credentials for upload
    #'
    #' @param file_id Unique identifier for the file to be updated.
    #' @param include (optional) Optionally include additional fields in the response.              Possible values: ObjectStoreAccess
    #' @param upload_part_count (optional) Optional number of parts for the presigned url for uploads (1 - 10000)
    #' @param body (optional) No description
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return API response (FileWriteableResponse) with additional information such as HTTP status code, headers
    #' @export
    UpdateFileWithHttpInfo = function(file_id, include = NULL, upload_part_count = NULL, body = NULL, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`file_id`)) {
        rlang::abort(message = "Missing required parameter `file_id`.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Missing required parameter `file_id`."))
      }



      if (`upload_part_count` > 10000) {
        rlang::abort(message = "Invalid value for `upload_part_count` when calling FilesApi$UpdateFile, must be smaller than or equal to 10000.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `upload_part_count` when calling FilesApi$UpdateFile, must be smaller than or equal to 10000."))
      }
      if (`upload_part_count` < 1) {
        rlang::abort(message = "Invalid value for `upload_part_count` when calling FilesApi$UpdateFile, must be bigger than or equal to 1.",
                     .subclass = "ApiException",
                     ApiException = ApiException$new(status = 0,
                                                     reason = "Invalid value for `upload_part_count` when calling FilesApi$UpdateFile, must be bigger than or equal to 1."))
      }


      query_params[["include"]] <- `include`

      query_params[["uploadPartCount"]] <- `upload_part_count`

      if (!is.null(`body`)) {
        local_var_body <- `body`$toJSONString()
      } else {
        body <- NULL
      }

      local_var_url_path <- "/v1/files/{fileId}"
      if (!missing(`file_id`)) {
        local_var_url_path <- gsub("\\{fileId\\}", URLencode(as.character(`file_id`), reserved = TRUE), local_var_url_path)
      }

      # API key authentication
      if ("Authorization" %in% names(self$api_client$api_keys) && nchar(self$api_client$api_keys["Authorization"]) > 0) {
        header_params["Authorization"] <- paste(unlist(self$api_client$api_keys["Authorization"]), collapse = "")
      }

      # The Accept request HTTP header
      local_var_accepts <- list("application/json")

      # The Content-Type representation header
      local_var_content_types <- list("application/json")

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "PATCH",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          write(local_var_resp$response, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$deserialize(local_var_resp$response, "FileWriteableResponse", loadNamespace("icar1")),
          error = function(e) {
            rlang::abort(message = "Failed to deserialize response",
                         .subclass = "ApiException",
                         ApiException = ApiException$new(http_response = local_var_resp))
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        local_var_resp
      } else if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        local_var_resp
      }
    }
  )
)
